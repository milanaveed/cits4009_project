---
title: "CITS4009 - Project 1"
author: "Mila Zhang (22756463)"
output: 
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
  html_notebook: 
    toc: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
	echo = TRUE,
	message = FALSE,
	warning = FALSE
)
```

# Introduction to the YouTube dataset

This project analises the data set of [Global YouTube Statistics 2023](https://www.kaggle.com/datasets/nelgiriyewithana/global-youtube-statistics-2023) and it can be obtained from the Kaggle platform.

This data collection provides an opportunity to analyse and uncover valuable insights from leading YouTubers. Packed with comprehensive details on high-profile creators, this dataset serves as a treasure for those breaking into content creation, enthusiastic about data, and anyone interested in the constantly changing landscape of online content.

# Performing ETL and setting up for plotting
## Loading libraries
```{r message=FALSE, warning=FALSE}
library(ggplot2)
library(gridExtra)
library(dplyr)
library(ggthemes)
library(numform)
library(treemapify)
library(timeDate)
library(lubridate)
library(reshape2)
library(ca)
library(ggmap)
library(sp)
library(maptools)
library(maps)
```

## Setting up a plotting theme
```{r}
my_color <- "#2061F2"
color_theme <- theme_few() + # Theme based on S. Few's "Practical Rules for Using Color in Charts"
               theme(plot.title = element_text(color = my_color),
                     plot.margin = margin(10, 20, 10, 20)) +
               theme(strip.text.x = element_text(size = 14, colour = "#202020"))
```

## Extracting data
```{r}
data.path <- './data/youtube_UTF_8.csv'
df <- read.csv(data.path)
```

## Data Overview
### Using head() to analyze the data
```{r message=FALSE, warning=FALSE}
head(df)
```
From the first 6 rows of the data, we can discover some missing values or invalid values which we will convert later according to the need of plotting.

### Using summary() to analyze the data
```{r message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE}
summary(df)
```

## Transforming data
Below are data treatments for missing/invalid/sentinel/outlier values, discretization, normalisation, log-scales and etc.

### Cleaning data

#### Cleaning column created_year
YouTube was created in 2005, so any channel on YouTube should be created in or after 2005. If the created year of a channel is earlier than 2005, then this variable contains invalid value. Also, valid values in the column `created_year` are supposed to be numbers, any NaN value should be turned into NA.
```{r}
df <- mutate(df,
             created_year = ifelse(created_year < 2005, NA, created_year))
```

We can check our data cleaning by counting the occurrences of each value in the column.
```{r}
df %>% count(created_year)
```
Now we have converted those invalid values into NA.


#### Cleaning column category
When conducting the earnings analysis and plotting the [Highest Yearly Earnings by Category](#earnings-by-category), some values of `nan` were involved initially. We first turn them into NA values.
```{r}
df <- mutate(df,
             category = ifelse(category=="nan", NA, category))
df %>% count(category)
```
After inspecting the occurrences of each value in the column category, we found that there are 46 NA values. 

#### Cleaning column Country
When conducting the earnings analysis and plotting the [Highest Yearly Earnings by Country](#earnings-by-country), some values of `nan` were involved initially. We first turn them into NA values.
```{r}
df <- mutate(df,
             Country = ifelse(Country=="nan", NA, Country))
df %>% count(Country)
```
After inspecting the occurrences of each value in the column Country, we found that there are 122 NA values. 

#### Dealing with missing values in column uploads
When plotting the relationship between the number of uploads and subscribers, there were some points with value 0. A leading Youtuber is supposed to have more than 0 uploads. We turn those 0 uploads into NAs.
```{r}
df <- mutate(df,
             uploads = ifelse(uploads==0, NA, uploads))
```

#### Dealing with invalid values in column video.views
According to common sense and through observation of the dataset, some values in the `video.views` are distinctively smaller than others. We turn those abnormal values into NAs.
```{r}
df <- mutate(df,
             video.views = ifelse(video.views<1000000, NA, video.views))
#df %>% count(df$video.views)
```


### Filtering data
TODO:
- take out the NA values in category, country, uploads? ISBAD indicator同步修改plotting

#### Dealing with missing values in column Country and category
When conducting the earnings analysis and plotting the [Highest Yearly Earnings by Country](#earnings-by-country), a country named `NA` was displayed initially. We replace the NAs with a new category `Missing`.
```{r}
df$Country.fix <- ifelse(is.na(df$Country),
                  "Missing", df$Country)
df$category.fix <- ifelse(is.na(df$category),
                  "Uncategorised", df$category)
```

#### Adding isBad indicators
Add isBad indicators to columns Country, category and uploads.
```{r}
df$Country_isBad <- is.na(df$Country)
df$category_isBad <- is.na(df$category)
df$uploads_isBad <- is.na(df$uploads)
df$video.views_isBad <- is.na(df$video.views)
```

#### Removing rows of NA in column created_year
****
When conducting the earnings analysis and plotting the [Highest Yearly Earnings by Country](#earnings-by-country), a country named `NA` was displayed initially. We remove the rows of Country with the value NA.
We calculte the occurrences of NA in created_year and there are only 6 invalid values, and thus has small impact on the whole dataset. We can remove it safely.
```{r}
df <- df[!is.na(df$created_year),]
```


****
```{r}
#template:
#count_value_2 <- filter(data_counted, column1 == 2)$n
```

## Loading data
Save the cleaned and transformed data
```{r}
#write.csv(df_filtered, "./data/youtube_data_cleaned")
```

# EDA: Content strategy analysis

## Popular channel category
Plot the channel category to gain insights of popular categories.
```{r}
# Sort the data
dfsums <- table(df$category.fix)

# Convert the table object into a data frame
categoryf <- as.data.frame(dfsums)

# Define the column names
colnames(categoryf) <- c("category", "count")

# Sort the data frame
categoryf <- transform(categoryf,
                       category = reorder(category, count))
# Plot the bar chart
ggplot(categoryf) +
  geom_bar(aes(x = category, y = count), stat = "identity", fill = my_color, alpha = 0.40) +
  coord_flip() +
  ggtitle("Number by Category") +
  color_theme
```

We can see that Entertainment, Music, People & Blogs are the most popular categories among those leading channels we anaylse.
 
## Relationship between the number of subscriber and category
```{r}
# Provide an overview of a set of visualization
library(GGally)
ggpairs(df[, c("subscribers","video.views","uploads")])
```

Plot the relationship between uploads and subscribers.
```{r}
p1 <- ggplot(df, aes(x = uploads, y = subscribers)) +
      geom_point(color = my_color, alpha = 0.3) + 
      #coord_cartesian(xlim = c(0,1000), ylim = c(0, 1.0e+08)) +
      labs(x = "") + # Hide x coordinate label
      ggtitle("Number of Uploads VS Subscribers") +
      color_theme

p2 <- ggplot(df, aes(x = uploads, y = subscribers)) +
      geom_smooth() + 
      color_theme

grid.arrange(p1, p2, ncol=1)
```


# EDA: Earnings analysis

## Distribution of earnings
Since "lowest_monthly_earnings" and "highest_monthly_earnings" are right-skewed variables, we will use two histograms to analyze each of the distribution: one with a log10 scale and one with a truncated linear scale.
```{r}
p1 <- ggplot(df, aes(x = lowest_monthly_earnings)) +
  geom_histogram(aes(y=..density..), binwidth= 0.10, fill = "grey") +
  geom_density(color= my_color)+
  scale_x_log10(breaks=c(100,2000,25000,200000))+
  annotate("text", x = 100, y = 0.5, label = paste("The lowest monthly earnings peak"," at around 25000", sep="\n"))+
  ggtitle("Distribution of Lowest Monthly Earnings (Log-scale)") +
  color_theme

# lme_Q1 <- boxplot.stats(df$lowest_monthly_earnings)$stats[2]
# lme_Q3 <- boxplot.stats(df$lowest_monthly_earnings)$stats[4]
# lme_IQR <- lme_Q3-lme_Q1
# lme_Q4 <- lme_Q3 + 1.5*lme_IQR

p2 <- ggplot(df, aes(x = lowest_monthly_earnings)) +
  geom_histogram(aes(y=..density..), binwidth=3000, fill = "grey") +
  geom_density(color=my_color)+
  scale_x_continuous(breaks=c(100000), limits = c(0, 2.1e+05), oob = scales::oob_squish)+
  scale_y_continuous(limits = c(0, 0.00005), oob = scales::oob_squish)+
  annotate("text", x = 100000, y = 3e-05, label = paste("Most of the distribution is concentrated", "at the low end: less than 100000", sep="\n"))+
  ggtitle("Distribution of Lowest Monthly Earnings") +
  color_theme

grid.arrange(p1, p2, ncol=1)
```

Most of the distribution is concentrated at the low end and less than 200000. And the lowest monthly earning peaks at around 25000.

```{r}
p1 <- ggplot(df, aes(x = highest_monthly_earnings)) +
  geom_histogram(aes(y=..density..), binwidth= 0.1, fill = "grey") +
  geom_density(color=my_color)+
  scale_x_log10(breaks=c(100,2000,25000,400000))+
  annotate("text", x = 500, y = 0.4, label = paste("The highest monthly earnings peak", "at around 400000", sep="\n"))+
  ggtitle("Distribution of Highest Monthly Earnings (Log-scale)") +
  color_theme

hme_Q1 <- boxplot.stats(df$highest_monthly_earnings)$stats[2]
hme_Q3 <- boxplot.stats(df$highest_monthly_earnings)$stats[4]
hme_IQR <- hme_Q3-hme_Q1
hme_Q4 <- hme_Q3 + 1.5*hme_IQR

p2 <- ggplot(df, aes(x = highest_monthly_earnings)) +
  geom_histogram(aes(y=..density..), binwidth=25000, fill = "grey") +
  geom_density(color=my_color)+
  scale_x_continuous(breaks=c(25000,hme_Q3), limits = c(0, hme_Q4), oob = scales::oob_squish)+
  ggtitle("Distribution of Highest Monthly Earnings") +
  color_theme

grid.arrange(p1, p2, ncol=1)
```

There is a big contrast in the The highest monthly earnings vary greatly among leading YouTubers, with few people having very high earnings and most people have relatively low 

## Earnings by category {#earnings-by-category}
Next we analyze how earnings differ across different YouTube channel categories.
```{r}
# Calculate median for each category
df$median_earnings_category <- with(df, ave(highest_yearly_earnings, category.fix, FUN=median))

# Create the boxplot
ggplot(df, aes(x = reorder(category.fix, median_earnings_category), y = highest_yearly_earnings)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(alpha = 0.15, color = my_color) +
  coord_flip(ylim = c(0, 6e+07)) +
  ggtitle("Highest Yearly Earnings by Category (Ordered by Median)") +
  color_theme
```

All categories have similar median values except Autos & Vehicles, whose median is significantly larger than others. Pets & Animals channel has the smallest median value of highest yearly earnings.


## Earnings by country {#earnings-by-country}
We can analyse the highest yearly earnings of the top 995 YouTube channels by country. There are too many countries in the dataset so we select 20 countries with the largest median value of highest yearly earnings. 

```{r warning=FALSE}
# Calculate median for each country
df$median_earnings_country <- with(df, ave(highest_yearly_earnings, Country.fix, FUN=median))

# Sort the data frame 
df_median_earnings_country_des <- df %>%
                                  arrange(desc(median_earnings_country))
# Get unique country names
unique_countries <- unique(df_median_earnings_country_des$Country)

# Select the first 20 unique country names
selected_countries <- unique_countries[1:20]

# Get all rows of the top 20 countries
top_20_country <- df_median_earnings_country_des[df_median_earnings_country_des$Country %in% selected_countries, ]

# Create the boxplot
ggplot(top_20_country, aes(x = highest_yearly_earnings, y = reorder(Country.fix, median_earnings_country))) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(alpha = 0.25, color = my_color) +
  coord_cartesian(xlim = c(0, 7e+07)) +
  ggtitle("Highest Yearly Earnings by Country (Ordered by Median)") +
  color_theme
```

The popular channel from Latvia has a distinctively higher value of highest yearly earnings among all the countries.


# EDA: Geospatial information

## Country distribution in space
With longitude and latitude provided in the dataset, we are able to visualise the country distribution in the aspect of earnings analysis.
```{r}
# Data preparation
visit.x <- df$Longitude
visit.y <- df$Latitude  

mp <- NULL #Create an empty map
mapworld <- borders("world",colour = "gray50",fill="white") #Draw the map
mp <- ggplot() + mapworld + ylim(-60, 90)
# Draw the points
mp2 <-
  mp + geom_point(aes(
    x = visit.x,
    y = visit.y,
    size = df$highest_yearly_earnings),
  color = my_color) +
  scale_size(range = c(2, 9)) +
  ggtitle("Geospatial Information About Highest Yearly Earnings")
mp3 <- mp2 + color_theme + theme(legend.position = "none")
mp3
```

Countries with high yearly earnings from the channels are mainly located in Europe, South Africa, the middle east and the South-East Asia.

## Country with popular channels
Plot the country information to gain insights of coutries with popular channels.
```{r}
# # Sort the data
# dfsums <- table(df$Country.fix)
# 
# # Convert the table object into a data frame
# countryf <- as.data.frame(dfsums)
# 
# # Define the column names
# colnames(countryf) <- c("country", "count")
# 
# # Sort the data frame
# countryf <- transform(countryf,
#                       country = reorder(country, count))
# 
# df3 <- countryf[df$Country_isBad == FALSE,]

# Filter the data frame
df1 <- df[df$Country_isBad == FALSE,]

# Sort the data
dfsums <- table(df1$Country)

# Convert the table object into a data frame
countryf <- as.data.frame(dfsums)

# Define the column names
colnames(countryf) <- c("country", "count")

# Sort the data frame
countryf <- transform(countryf,
                      country = reorder(country, count))
# Plot the bar chart
ggplot(countryf) +
  geom_bar(aes(x = country, y = count), stat = "identity", fill = my_color, alpha = 0.40) +
  coord_flip() +
  ggtitle("Number by Country") +
  color_theme +
  theme(axis.text.y = element_text(size = rel(0.55)))
```

Among those countries, the US, India, and Brazil have the most amount of leading YouTubers.


# Code for Shiny App
```{r}

```
